import sys
import math
import collections
import csv
import time
import json
import requests
import certifi
import datetime, dateutil.parser
import statistics
from decimal import Decimal
from datetime import datetime
from scipy.stats import skew

def mean(dict_of_values): # media
    return sum(dict_of_values.values()) / max(len(dict_of_values), 1)

def variance(dict_of_values, mean_of_values): # varianza, necessaria per il calcolo della deviazione standard
    n = len(dict_of_values)
    deviations = [(x - mean_of_values) ** 2 for x in dict_of_values.values()]
    variance = sum(deviations) / max(n, 1)
    return variance

def sdev(dict_of_values, mean_of_values): # deviazione standard
    var = variance(dict_of_values, mean_of_values)
    std_dev = math.sqrt(var)
    return std_dev
    
# apertura dei file
addrs= "addresses.csv"              # indirizzi smart contract
result = open("result.csv", "w+")   # conterra' le features degli smart contract
writer = csv.writer(result, lineterminator = '\n') # writer per scrivere sul file
writer.writerow(['address', 'balance', 'N_maxpayment', 'investment_in', 'payment_out', 'mean_v1', 'sdev_v1', 'skew_v1', 'mean_v2', 'sdev_v2', 'skew_v2', 'known_rate', 'paid_rate', 'paid_one',])
addr_list = [] # lista che mantiene gli indirizzi degli smart contract

with open(addrs, 'r', encoding = 'utf-8-sig') as f: 
    reader = csv.reader(f, delimiter = ',', quotechar = '|') # reader: oggetto che itera le linee del file csv 
    for row in reader:
        addr = row[0] # si legge per righe, il primo elemento di ogni riga viene inserito in addr
        addr_list.append(addr)

for addr in addr_list: # ciclo su tutti gli indirizzi presenti nella lista ponzi
    print("Retrieving transactions of contract ", addr)
    sys.stdout.flush() # si ripulisce lo stream di output

    count_in, count_out = 0, 0   # contatore delle transazioni interne ed esterne del contratto, si considerano solo quelle con valore > 0
    eth_in, eth_out = 0, 0       # eth in entrata ed in uscita, servira' per calcolare il bilancio
    dict_kr_in = {}
    dict_kr_out = {}
    dict_addr_tx_out = {}        # dizionario, <indirizzo: #pagamenti fatti dal contratto verso l'indirizzo>
    dict_addr_tx_in = {}         # dizionario, <indirizzo: #pagamenti inviati al contratto dall'indirizzo>
    dict_addr_eth_in = {}        # dizionario, <indirizzo: amount inviati al contratto dall'indirizzo>
    dict_addr_eth_out = {}       # dizionario, <indirizzo: amount ricevuti dall'indirizzo>
    
    print("Get normal transaction of contract ", addr)
    normal_tx_url = "https://api.etherscan.io/api?module=account&action=txlist&address=" + addr + \
                   "&startblock=0&endblock=99999999&page=1&offset=10000&sort=asc&apikey=Q9C796N54G4G4S6JP91ERNQTM9VWC463BP"
    response_normal = requests.get(normal_tx_url, verify = certifi.where()) # la get restituisce un Response obj
    address_content_normal = response_normal.json() # la risposta e' in formato json, si ottiene un dizionario python
    result_normal = address_content_normal.get('result') # facendo la get e si ottiene tutto cio' che sta dopo result, si ottiene una lista

    for t in result_normal: # transazioni in ingresso nel contratto
        if (t['isError'] == '0'): # assenza di errori nella transazione
            eth_val = int(t['value'])
            if t['from'] not in dict_kr_in:
                dict_kr_in[t['from']] = int(t['timeStamp']) # se e' la prima volta che compare il contratto, salvo la data
            if (eth_val > 0): # se il valore della transazione e' > 0 allora...
                if t['from'] in dict_addr_tx_in: # se l'indirizzo e' gia' presente, cioe' il mittente della transazione aveva gia' pagato il contratto
                    dict_addr_tx_in[t['from']] += 1 # incremento il valore associato alla chiave, che indica il numero di transazioni
                    dict_addr_eth_in[t['from']] += round(Decimal(eth_val)/Decimal('1000000000000000000'), 6) # incremento il valore associato alla chiave, che indica quanto eth ha inviato
                else:
                    dict_addr_tx_in[t['from']] = 1 # se non era ancora presente allora e' la prima volta che invia soldi al contratto
                    dict_addr_eth_in[t['from']] = round(Decimal(eth_val)/Decimal('1000000000000000000'), 6)
                eth_in += eth_val # incremento la variabile che contiene l'ETH ricevuto
                count_in += 1

    print("Get internal transaction of contract ", addr)
    internal_tx_url = "https://api.etherscan.io/api?module=account&action=txlistinternal&address=" + addr + \
                       "&startblock=0&endblock=99999999&page=1&offset=10000&sort=asc&apikey=Q9C796N54G4G4S6JP91ERNQTM9VWC463BP"
    response_internal = requests.get(internal_tx_url, verify = certifi.where())
    address_content_internal = response_internal.json()
    result_internal = address_content_internal.get("result")

    for t in result_internal:
        if (t['isError'] != '0'): continue # siamo in presenza di errore
        eth_val = int(t['value'])
        if (t['from'].lower() == addr.lower()):  # internal transaction from contract to t['to'] aka addr, flusso di ETH uscente                       
            if (eth_val > 0):
                if t['to'] in dict_addr_tx_out:
                    dict_addr_tx_out[t['to']] += 1
                    dict_addr_eth_out[t['to']] += round(Decimal(eth_val)/Decimal('1000000000000000000'), 6)
                else:
                    dict_addr_tx_out[t['to']] = 1 # se non era ancora presente allora e' il primo pagamento che ha ricevuto
                    dict_addr_eth_out[t['to']] = round(Decimal(eth_val)/Decimal('1000000000000000000'), 6)
                    dict_kr_out[t['to']] = int(t['timeStamp'])
                eth_out += eth_val
                count_out +=1
        else:  # internal transaction from t['from'] to contract, flusso di ETH entrante
            if t['from'] not in dict_kr_in:
                dict_kr_in[t['from']] = int(t['timeStamp'])
            if (eth_val > 0): # se il valore della transazione e' >0 allora...
                if t['from'] in dict_addr_tx_in: # se l'indirizzo e' gia' presente, cioe' il mittente della transazione aveva gia' pagato il contratto
                    dict_addr_tx_in[t['from']] += 1 # incremento il valore associato alla chiave, che indica il numero di transazioni
                    dict_addr_eth_in[t['from']] += round(Decimal(eth_val)/Decimal('1000000000000000000'), 6) # incremento il valore associato alla chiave, che indica quanto eth ha inviato
                else:
                    dict_addr_tx_in[t['from']] = 1 # se non era ancora presente allora e' la prima volta che invia soldi al contratto
                    dict_addr_eth_in[t['from']] = round(Decimal(eth_val)/Decimal('1000000000000000000'), 6)
                eth_in += eth_val # incremento la variabile che contiene l'ETH ricevuto
                count_in += 1
    
    # calcolo le statistiche
    balance = round(Decimal(eth_in - eth_out)/Decimal('1000000000000000000'),6)                     # bilancio del contratto
    
    if not list(dict_addr_tx_out.values()):
        N_maxpayment = 0
    else:
        N_maxpayment = max(dict_addr_tx_out.values())   # numero massimo dei pagamenti fatti dal contratto verso un partecipante
    
    paying_addresses = len(dict_addr_tx_in)          # numero di indirizzi diversi che hanno inviato ETH al contratto
    paid_addresses = len(dict_addr_tx_out)           # numero di indirizzi diversi che hanno ricevuto ETH dal contratto
    
    v1 = {key: dict_addr_tx_out[key] - dict_addr_tx_in.get(key, 0) for key in dict_addr_tx_out} # creo un dizionario che ha tutte le chiavi di dict_addr_tx_in e come valori la differenza fra i valori dei due dizionari per chiavi uguali 
    for k in dict_addr_tx_in:
        if k not in dict_addr_tx_out:
	        v1[k] = - dict_addr_tx_in[k] # aggiungo le chiavi che sono presenti in dict_addr_tx_out ma che non sono state inserite in v1
    
    v2 = {key: dict_addr_eth_out[key] - dict_addr_eth_in.get(key, 0) for key in dict_addr_eth_out}
    for k in dict_addr_eth_in:
        if k not in dict_addr_eth_out:
	        v2[k] = - dict_addr_eth_in[k]
    
    mean_v1 = round(Decimal(mean(v1)), 6)   # media del vettore differenza fra dict_addr_tx_in (contiene il numero di volte che un indirizzo ha inviato ETH al contratto) e dict_addr_tx_out (contiene il numero di volte che un indirizzo ha ricevuto ETH dal contratto) per ogni indirizzo
    sdev_v1 = round(sdev(v1, mean_v1), 6)   # sdev del vettore differenza dict_addr_tx_in e dict_addr_tx_out
    l_v1 = list(v1.values())
    list_v1 = [float(i) for i in l_v1]
    if not list_v1:
        skew_v1 = 0
    else:
        skew_v1 = round(skew(list_v1, bias=False), 6)
    
    mean_v2 = round(Decimal(mean(v2)), 6)   # media del vettore differenza fra dict_addr_eth_in (contiene l'ammontare di ETH inviato al contratto da un indirizzo) e dict_addr_eth_out (contiene l'ammontare di ETH ricevuto dal contratto e inviato ad un indirizzo) per ogni indirizzo
    sdev_v2 = round(sdev(v2, mean_v2), 6)   # sdev del vettore differenza dict_addr_eth_in e dict_addr_eth_out
    l_v2 = list(v2.values())
    list_v2 = [float(i) for i in l_v2]
    if not list_v2:
        skew_v2 = 0
    else:
        skew_v2 = round(skew(list_v2, bias=False), 6)
    
    paid_rate = round(Decimal(count_out)/Decimal(max(count_in, 1)), 4) # rapporto fra le transazioni in uscita dal contratto e quelle in ingresso nel contratto: tx_out/tx_in

    # conto le chiavi presenti sia in dict_addr_tx_out che in dict_addr_tx_in, in questo modo ho il numero di quanti investitori sono stati pagati
    count_paid_investors = 0 # numero di investitori che sono stati pagati
    for k in dict_addr_tx_out:
        if k in dict_addr_tx_in:
            count_paid_investors += 1 # non posso usare la variabile paid_addresses poiche' qui ci possono essere messi anche non investitori es: creatore del contratto che non ha investito ma ha ricevuto soldi 

    count_kr = 0
    for k in dict_kr_out:
        if k in dict_kr_in:
            if dict_kr_in[k] <= dict_kr_out[k]:
                count_kr+=1

    paid_one = round(Decimal(count_paid_investors)/Decimal(max(paying_addresses, 1)), 4)   # perche' faccio count/... anzi che len(dict_addr_tx_out)/... perche' ci potrebbe essere qualche indirizzo (i.e. il proprietario) che pur non investendo nulla nel contratto potrebbe ricevere ETH, noi qui non vogliamo considerarlo
    known_rate = round(Decimal(count_kr)/Decimal(max(paid_addresses, 1)), 4)
    writer.writerow([addr, str(balance), str(N_maxpayment), str(count_in), str(count_out), str(mean_v1), str(sdev_v1), str(skew_v1), str(mean_v2), str(sdev_v2), str(skew_v2), str(known_rate), str(paid_rate), str(paid_one)]) 
    time.sleep(0.2)

result.close()
print("end of the journey!")
